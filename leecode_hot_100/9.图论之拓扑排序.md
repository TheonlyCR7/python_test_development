### 图论中的拓扑排序详解

---

#### **1. 定义与核心概念**
**拓扑排序（Topological Sorting）** 是对有向无环图（DAG, Directed Acyclic Graph）的所有顶点的一种线性排序，使得：
- 对于图中的每一条有向边 \(u \rightarrow v\)，顶点 \(u\) 在排序中出现在顶点 \(v\) 的前面。
- 若图存在环，则无法进行拓扑排序。

**关键性质**：
- 拓扑排序的结果不唯一（可能存在多个合法序列）。
- 仅适用于 DAG（有向无环图）。

---

#### **2. 实现方法**
拓扑排序有两种经典实现方式：**Kahn 算法（BFS）** 和 **基于DFS的逆后序排序**。

---

##### **方法一：Kahn 算法（基于BFS）**
**核心思想**：  
通过维护顶点的入度（In-degree）表，逐步选择入度为0的顶点，并更新其邻居的入度。

**步骤**：
1. **初始化**：统计每个顶点的入度，将入度为0的顶点加入队列。
2. **迭代处理**：
   - 从队列中取出顶点 \(u\)，加入排序结果。
   - 遍历 \(u\) 的所有邻接顶点 \(v\)，将 \(v\) 的入度减1。若减后 \(v\) 的入度为0，加入队列。
3. **终止条件**：
   - 若最终排序结果包含所有顶点，则图是 DAG，排序有效。
   - 若排序结果缺失顶点，则图中存在环。

**代码示例（Python）**：
```python
from collections import deque

def topological_sort_bfs(graph):
    in_degree = {u: 0 for u in graph}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    
    queue = deque([u for u in in_degree if in_degree[u] == 0])
    result = []
    
    while queue:
        u = queue.popleft()
        result.append(u)
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    
    return result if len(result) == len(graph) else None  # 若存在环，返回None
```

---

##### **方法二：DFS逆后序排序**
**核心思想**：  
通过深度优先搜索（DFS）的后序遍历记录顶点，最终反转顺序得到拓扑排序。

**步骤**：
1. **递归访问**：选择一个未访问的顶点 \(u\)，递归访问其所有邻接顶点 \(v\)。
2. **记录后序**：当 \(u\) 的所有邻居访问完成后，将 \(u\) 标记为已访问，并加入后序列表。
3. **检测环**：若在递归过程中发现已访问但未完成的顶点（存在反向边），说明存在环。
4. **反转结果**：最终将后序列表反转，得到拓扑排序。

**代码示例（Python）**：
```python
def topological_sort_dfs(graph):
    visited = {}
    result = []
    has_cycle = False
    
    def dfs(u):
        nonlocal has_cycle
        if has_cycle:
            return
        if u in visited:
            if visited[u] == 0:  # 正在访问中，发现环
                has_cycle = True
            return
        visited[u] = 0  # 标记为访问中
        for v in graph[u]:
            dfs(v)
        visited[u] = 1  # 标记为已完成
        result.append(u)
    
    for u in graph:
        if u not in visited:
            dfs(u)
            if has_cycle:
                return None  # 存在环，返回None
    
    return result[::-1]  # 反转后序为拓扑排序
```

---

#### **3. 时间复杂度**
- **Kahn 算法**：\(O(V + E)\)，每个顶点和边被处理一次。
- **DFS 方法**：\(O(V + E)\)，需遍历所有顶点和边。

---

#### **4. 应用场景**
1. **任务调度**：处理任务间的依赖关系（如编译顺序、课程安排）。
2. **依赖分析**：确定执行顺序以确保前置条件满足。
3. **死锁检测**：若无法生成拓扑排序，说明存在循环依赖。
4. **数据流分析**：编译器优化、静态代码分析。

---

#### **5. 典型例题**
1. **课程表问题（LeetCode 207）**  
   - **问题**：判断是否可能完成所有课程的学习（无环）。
   - **解法**：拓扑排序检测环。

2. **课程表 II（LeetCode 210）**  
   - **问题**：返回课程学习的正确顺序。
   - **解法**：拓扑排序输出序列。

3. **外星人词典（LeetCode 269）**  
   - **问题**：根据单词字典序推断字符顺序。
   - **解法**：构建字符依赖图，进行拓扑排序。

---

#### **6. 常见问题与注意事项**
1. **环检测**：两种方法均可检测环：
   - Kahn 算法：若最终排序结果不包含所有顶点，则存在环。
   - DFS 方法：通过标记访问状态（0=访问中，1=已完成）检测反向边。

2. **多解性**：拓扑排序结果不唯一，需根据题目要求选择特定顺序（如字典序最小解可在 Kahn 算法中使用优先队列）。

3. **初始化细节**：确保图的顶点被完全遍历（处理非连通图）。

---

#### **7. BFS vs DFS 选择**
| **场景**         | **推荐方法**     | **原因**                                 |
| ---------------- | ---------------- | ---------------------------------------- |
| 需要最小字典序   | BFS（优先队列）  | BFS按层级处理，优先队列保证字典序。      |
| 需快速检测环     | Kahn 算法（BFS） | 队列处理中途即可发现无法完成所有顶点。   |
| 复杂递归逻辑处理 | DFS              | 递归天然适合深度优先遍历（如路径记录）。 |

---

#### **8. 代码模板总结**
- **Kahn 算法**：维护入度表 + 队列。
- **DFS 方法**：递归后序 + 反转结果 + 环检测。

掌握这两种实现方式，能灵活应对不同场景下的拓扑排序需求。