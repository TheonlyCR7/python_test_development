## 70.爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

思路：

* 到达第n阶的最后一步可能是从n-1阶（爬1阶）或n-2阶（爬2阶），因此总方法数为这两种情况之和。
* **状态定义**：`dp[i]` 表示到达第i阶楼梯的方法数。
* **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`。
* `dp[1] = 1`（只有1种方法：爬1阶）。
* `dp[2] = 2`（两种方法：1+1或直接2阶）。

代码

```
def climbStairs(n: int) -> int:
    if n == 1:  # 当长度为1时
        return 1
    a, b = 1, 2  # 初始化为dp[1]和dp[2]
    for _ in range(3, n+1): # 巧妙设计，n+1
        c = a + b
        a = b
        b = c
    return b # 返回b
```



## 118.杨辉三角

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://s2.loli.net/2025/02/15/rcvl4axAKoCVUFZ.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```



思路差不多，关键是找到状态转移方程

```
class Solution(object):
    def generate(self, numRows):
        """
        :type numRows: int
        :rtype: List[List[int]]
        """
        ans = []
        numRow1 = [1]
        ans.append(numRow1)
        if numRows == 1: return ans
        
        numRow2 = [1,1]
        
        ans.append(numRow2)
        last = numRow2
        for i in range(3, numRows+1):
            cur = [1]
            for j in range(1, i-1):
                cur.append(last[j-1] + last[j])
            cur.append(1)
            last = cur
            ans.append(last)
        return ans
```





## 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 **示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```



思路：

* ### **分步解析与代码实现**

  ---

  #### **1. 问题分析**
  - **目标**：在不能偷相邻房屋的限制下，求能偷到的最大金额。
  - **关键观察**：对于第i个房屋，有两种选择：
    1. **偷第i间** → 总金额 = 前i-2间的最大金额 + 当前房屋金额 `nums[i]`。
    2. **不偷第i间** → 总金额 = 前i-1间的最大金额。
    
    - 取两者中的较大值作为最优解。

  ---

  #### **2. 定义状态**
  - **状态定义**：`dp[i]` 表示前i间房屋能偷到的最大金额。
  - **状态转移方程**：  
    ```python
    dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])  
    # 注意：nums的索引从0开始，dp的索引从1开始（dp[1]对应nums[0]）
    ```

  ---

  #### **3. 初始条件**
  - `dp[0] = 0`（没有房屋可偷）。
  - `dp[1] = nums[0]`（只有一间房屋时必偷）。

  ---

  #### **4. 递推过程示例（以示例1：nums = [1,2,3,1]为例）**
  | 房屋编号 | 0       | 1       | 2                   | 3                   |
  | -------- | ------- | ------- | ------------------- | ------------------- |
  | nums     | 1       | 2       | 3                   | 1                   |
  | dp数组   | dp[0]=0 | dp[1]=1 | dp[2]=max(1, 0+2)=2 | dp[3]=max(2, 1+3)=4 |

  最终结果：`dp[4] = 4`。

  ---

  #### **5. 空间优化**
  由于 `dp[i]` 只依赖前两个状态，可用两个变量滚动更新：
  ```python
  def rob(nums: list) -> int:
      if not nums:
          return 0
      n = len(nums)
      if n == 1:
          return nums[0]
      
      a, b = nums[0], max(nums[0], nums[1])  # 初始化dp[1]和dp[2]
      for i in range(2, n):
          c = max(b, a + nums[i])  # dp[i] = max(dp[i-1], dp[i-2] + nums[i])
          a, b = b, c
      return b
  ```

  ---

  #### **6. 代码验证**
  - **示例1**：`nums = [1,2,3,1]` → 输出4。
  - **示例2**：`nums = [2,7,9,3,1]` → 输出12。
  - **边界测试**：
    - `nums = []` → 输出0。
    - `nums = [5]` → 输出5。
    - `nums = [2,1,1,2]` → 输出4（偷第0和第3间）。

  ---

  #### **7. 复杂度分析**
  - **时间复杂度**：O(n)，遍历一次数组。
  - **空间复杂度**：O(1)，仅用常数变量。

  ---

  ### **总结**
  通过定义状态和递推关系，将问题转化为动态规划问题。核心思想是**每一步选择是否偷当前房屋，并利用前序结果避免重复计算**。此解法高效且清晰，是动态规划在约束条件下求最优解的典型应用。

代码

```python
class Solution(object):
    def rob(self, nums):
        if not nums: return 0
        n = len(nums)
        if n == 1: return nums[0]
        a = nums[0]
        b = max(nums[0], nums[1])
        for i in range(2, n):
        	# 计算前i+1间屋子能偷的最大值
            # max(偷了第i间的屋子时的最大值, 没偷第i间为a+第(i+1)间)
            c = max(b, a + nums[i])
            a = b
            b = c
        return b
```



## 279.完全平方数

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 **示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```



