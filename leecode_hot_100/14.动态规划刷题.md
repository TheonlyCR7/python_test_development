## 70.爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

思路：

* 到达第n阶的最后一步可能是从n-1阶（爬1阶）或n-2阶（爬2阶），因此总方法数为这两种情况之和。
* **状态定义**：`dp[i]` 表示到达第i阶楼梯的方法数。
* **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`。
* `dp[1] = 1`（只有1种方法：爬1阶）。
* `dp[2] = 2`（两种方法：1+1或直接2阶）。

代码

```
def climbStairs(n: int) -> int:
    if n == 1:  # 当长度为1时
        return 1
    a, b = 1, 2  # 初始化为dp[1]和dp[2]
    for _ in range(3, n+1): # 巧妙设计，n+1
        c = a + b
        a = b
        b = c
    return b # 返回b
```



## 118.杨辉三角

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://s2.loli.net/2025/02/15/rcvl4axAKoCVUFZ.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```



思路差不多，关键是找到状态转移方程

* ### 1. **定义状态**

  定义一个状态 `dp[i]`，表示第 `i` 行的杨辉三角的值。`dp[i]` 是一个列表，包含了从第 1 行到第 `i` 行的所有数。

  具体地：

  - `dp[i]` 是一个长度为 `i + 1` 的列表，表示第 `i` 行的所有元素。
  - 每一行的第一个和最后一个数都是 `1`，而中间的元素是上一行相邻两个数之和。

  ### 2. **状态转移方程**

  - **第一列**和**最后一列**的元素都为 `1`。
  - **中间元素**是上一行的相邻两个元素之和，即： `dp[i][j]=dp[i−1][j−1]+dp[i−1][j]` 
- 其中 `i` 是当前行的索引，`j` 是当前行中的列索引。
  
### 3. **初始化**
  
- **第一行** `dp[0]` 初始化为 `[1]`，因为第一行只有一个数 `1`。
  
### 4. **计算顺序**
  
  - 我们从第二行开始逐行构建杨辉三角。
  - 对于每一行：
    - 初始化该行为 `[1] * (i + 1)`。
  - 对于 `1 <= j < i`，计算 `dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`。
  
### 5. **返回值**
  
  最终返回 `dp` 数组，其中 `dp[numRows - 1]` 即为生成的杨辉三角的最后一行。

```python
def generate(numRows: int):
    # 步骤 3: 初始化
    if numRows == 0:
        return []
    
    dp = [[1]]  # 第一行是 [1]
    
    # 步骤 4: 计算顺序
    for i in range(1, numRows):
        row = [1] * (i + 1)  # 初始化当前行，全部为 1
        # 步骤 2: 填充中间元素
        for j in range(1, i):
            row[j] = dp[i - 1][j - 1] + dp[i - 1][j]
        dp.append(row)  # 将当前行添加到 dp 中
    
    # 步骤 5: 返回值
    return dp
```





## 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 **示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```



思路：

* ### **分步解析与代码实现**

  ---

  #### **1. 问题分析**
  - **目标**：在不能偷相邻房屋的限制下，求能偷到的最大金额。
  - **关键观察**：对于第i个房屋，有两种选择：
    1. **偷第i间** → 总金额 = 前i-2间的最大金额 + 当前房屋金额 `nums[i]`。
    2. **不偷第i间** → 总金额 = 前i-1间的最大金额。
    
    - 取两者中的较大值作为最优解。

  ---

  #### **2. 定义状态**
  - **状态定义**：`dp[i]` 表示前i间房屋能偷到的最大金额。
  - **状态转移方程**：  
    
    ```python
    dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])  
    # 注意：nums的索引从0开始，dp的索引从1开始（dp[1]对应nums[0]）
  ```
  
---
  
  #### **3. 初始条件**
  - `dp[0] = 0`（没有房屋可偷）。
- `dp[1] = nums[0]`（只有一间房屋时必偷）。
  
---
  
  #### **4. 递推过程示例（以示例1：nums = [1,2,3,1]为例）**
  | 房屋编号 | 0       | 1       | 2                   | 3                   |
  | -------- | ------- | ------- | ------------------- | ------------------- |
  | nums     | 1       | 2       | 3                   | 1                   |
| dp数组   | dp[0]=0 | dp[1]=1 | dp[2]=max(1, 0+2)=2 | dp[3]=max(2, 1+3)=4 |
  
最终结果：`dp[4] = 4`。
  
---
  
  #### **5. 空间优化**
  由于 `dp[i]` 只依赖前两个状态，可用两个变量滚动更新：
  ```python
  def rob(nums: list) -> int:
      if not nums:
          return 0
      n = len(nums)
      if n == 1:
          return nums[0]
      
      a, b = nums[0], max(nums[0], nums[1])  # 初始化dp[1]和dp[2]
      for i in range(2, n):
          c = max(b, a + nums[i])  # dp[i] = max(dp[i-1], dp[i-2] + nums[i])
          a, b = b, c
      return b
```
  
---
  
  #### **6. 代码验证**
  - **示例1**：`nums = [1,2,3,1]` → 输出4。
  - **示例2**：`nums = [2,7,9,3,1]` → 输出12。
  - **边界测试**：
    - `nums = []` → 输出0。
    - `nums = [5]` → 输出5。
  - `nums = [2,1,1,2]` → 输出4（偷第0和第3间）。
  
---
  
  #### **7. 复杂度分析**
  - **时间复杂度**：O(n)，遍历一次数组。
- **空间复杂度**：O(1)，仅用常数变量。
  
---
  
  ### **总结**
  通过定义状态和递推关系，将问题转化为动态规划问题。核心思想是**每一步选择是否偷当前房屋，并利用前序结果避免重复计算**。此解法高效且清晰，是动态规划在约束条件下求最优解的典型应用。

代码

```python
class Solution(object):
    def rob(self, nums):
        if not nums: return 0
        n = len(nums)
        if n == 1: return nums[0]
        a = nums[0]
        b = max(nums[0], nums[1])
        for i in range(2, n):
        	# 计算前i+1间屋子能偷的最大值
            # max(偷了第i间的屋子时的最大值, 没偷第i间为a+第(i+1)间)
            c = max(b, a + nums[i])
            a = b
            b = c
        return b
```



## 279.完全平方数

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 **示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```



因为是要用平方之后的数来组成n，所以需要找到n和(n-平方数)之间的关系，通过已知前两个的情况，来推出后面的情况，已知`dp[i - j * j]`的值，来找到dp[i]的值

代码

```python
class Solution(object):
    def numSquares(self, n):
        # 创建一个 DP 数组，初始化为一个较大的数
        dp = [float('inf')] * (n + 1)   # 记得加中括号表示列表
        dp[0] = 0  # 0 需要 0 个完全平方数
        
        # 从 1 到 n，计算最少的完全平方数
        for i in range(1, n + 1):
            j = 1
            while j * j <= i:
                dp[i] = min(dp[i], dp[i - j * j] + 1)
                j += 1
        
        return dp[n]
```





## 322.零钱兑换

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 **示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

思路

* 这个问题是典型的**完全背包问题**，我们可以使用 **动态规划** 来解决它。目标是通过给定的硬币面额，找出最少的硬币数量来组成目标金额。如果无法组合成目标金额，则返回 -1。

  ### 动态规划的思路

  我们可以定义一个动态规划数组 `dp`，其中 `dp[i]` 表示凑成金额 `i` 所需的最少硬币个数。

  #### 状态转移方程

  - 初始化 `dp[0] = 0`，因为金额为 0 时需要 0 个硬币。
  - 对于其他金额 `i`，我们可以尝试用每种硬币 `coin` 来凑成 `i`，状态转移公式为： `dp[i]=min⁡(dp[i],dp[i−coin]+1)` 其中 `coin` 是当前尝试的硬币面额，`dp[i - coin] + 1` 表示使用当前硬币后，剩余金额 `i - coin` 所需的最少硬币数量，加上当前硬币（`+1`）。

  #### 边界条件：

  - `dp[0] = 0`：金额为 0 时，需要 0 个硬币。
  - 对于其他 `i`，初始化时设置 `dp[i] = ∞`（表示尚未找到解）。

  #### 结果：

  - 最终 `dp[amount]` 存储了凑成目标金额 `amount` 所需的最少硬币个数。
  - 如果 `dp[amount]` 仍然是 `∞`，说明无法凑成该金额，返回 -1。


代码
```python
def coinChange(coins, amount):
    # 初始化 dp 数组，大小为 amount + 1，所有值初始为 ∞，dp[0] = 0
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    # 遍历所有金额从 1 到 amount
    for i in range(1, amount + 1):
        # 遍历每个硬币
        for coin in coins:
            if i >= coin:
                # 对于金额i来说，所需要的
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    # 如果 dp[amount] 还是 ∞，说明无法凑成该金额
    return dp[amount] if dp[amount] != float('inf') else -1
```



## 139.单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 **示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```





代码

```python
class Solution(object):
    def wordBreak(self, s, wordDict):
        # dp[i]表示对于字符串s来说，0-i字符串是否可以在wordDict中拼成
        dp = [False] * (len(s)+1) # 先默认全部为False
        dp[0] = True  # 0长度必定可以拼成
        wordDict = set(wordDict)  # 变成集合

        for i in range(1, len(s)+1):  # 遍历字符串s
            for j in range(i):
                # i = j + j:i
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break  # 一旦找到一个拼接方案就可以停止
        return dp[len(s)]          # 返回整个字符串是否可以拼接出来
```



## 300.最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```



思路：

* #### **动态规划五部曲**：

  1. **定义状态**：
     - 设 `dp[i]` 表示以下标 `i` 结尾的**最长递增子序列**的长度。
  2. **状态转移方程**：
     - 对于每一个位置 `i`，需要向前寻找比 `nums[i]` 小的数 `nums[j]`，如果存在 `nums[j] < nums[i]`，说明可以将 `nums[i]` 接在 `nums[j]` 的递增子序列之后，长度加 1。
     - 因此： dp[i]=max⁡(dp[i],dp[j]+1), 其中 j<i 且 nums[j]<nums[i]
  3. **初始化**：
     - 初始时，每个元素的最长递增子序列长度至少为 1（它自己本身就是一个子序列）。
     - `dp = [1] * len(nums)`
  4. **遍历顺序**：
     - 外层遍历 `i` 从 0 到 `len(nums)-1`。
     - 内层遍历 `j` 从 0 到 `i-1`，检查 `nums[j] < nums[i]`。
  5. **返回结果**：
     - 返回 `dp` 数组中的最大值 `max(dp)`。



```python
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        dp = [1] * n
        for i in range(1, n):
        	for j in range(0, i):
        		if nums[j] < nums[i]:
        			dp[i] = max(dp[i], dp[j]+1)
        return max(dp)
```

tip:

* 状态转移方程中，是只前一个状态到后一个状态，很多情况下，并不是



## 152.乘积最大子数组

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组

（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```



思路：

* 这是一个典型的 **动态规划** 问题，要求找出数组中乘积最大的连续子数组。考虑到乘积可能会因为负数变号，我们需要同时追踪两个变量：

  1. 当前子数组的最大乘积。
  2. 当前子数组的最小乘积（因为负数乘以负数可能得到正数）。

  ### 思路

  - 对于每个元素，我们有两个状态：

    - `max_prod[i]`：到当前位置 `i` 为止，乘积最大的子数组的乘积。
    - `min_prod[i]`：到当前位置 `i` 为止，乘积最小的子数组的乘积（负数情况）。

  - 对于每个元素，我们有两个选择：

    - 乘上当前元素，得到新的最大/最小乘积。
    - 或者从当前位置开始重新计算子数组。

    由于乘积可能变号，我们需要同时考虑：

    - 乘上当前元素：`max_prod[i-1] * nums[i]` 和 `min_prod[i-1] * nums[i]`。
    - 当前位置作为新的起点：`nums[i]`。

  ### 状态转移方程：

  - `max_prod[i] = max(nums[i], max_prod[i-1] * nums[i], min_prod[i-1] * nums[i])`
  - `min_prod[i] = min(nums[i], max_prod[i-1] * nums[i], min_prod[i-1] * nums[i])`

  ### 初始化：

  - 初始时，`max_prod` 和 `min_prod` 都等于第一个元素，因为第一个元素就是唯一的子数组。

  ### 最终答案：

  - 遍历完成后，最大值就是 `max_prod` 数组中的最大值。

```python
class Solution(object):
    def maxProduct(self, nums):

        if not nums: return None
        max_ans = min_ans = result = nums[0]

        for i in range(1, len(nums)): # 要从1开始，不能重复乘
            if nums[i] < 0:
                max_ans, min_ans = min_ans, max_ans
            max_ans = max(max_ans*nums[i], nums[i])
            min_ans = min(min_ans*nums[i], nums[i])
            result = max(result, max_ans)
        return result
        
```



## 416.分割等和子集

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 **示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```



代码

```python
def canPartition(nums):
    total_sum = sum(nums)
    # 如果总和是奇数，不能分割成两个和相等的子集
    if total_sum % 2 != 0:
        return False
    
    # 目标和为总和的一半
    target = total_sum // 2
    # dp[i]表示是否可以组成和为i，要表示0到target的所有状态
    dp = [False] * (target + 1) # 所以长度为target+1
    dp[0] = True  # 和为 0 的子集总是存在的
    
    # 遍历 nums 数组
    for num in nums:
        # 从后往前更新 dp 数组
        for j in range(target, num - 1, -1):
            dp[j] = dp[j] or dp[j - num]
    
    return dp[target]

```



## 32.最长有效括号

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```



动态规划

* ### 1. **定义状态**

  我们需要定义一个状态 `dp[i]`，表示 **以索引 `i` 结尾的最长有效括号子串的长度**。具体地，`dp[i]` 是在字符串 `s[0..i]` 中，所有有效括号子串中，**以 `i` 结尾的最大长度**。

  ### 2. **状态转移方程**

  - 如果 

    ```
    s[i]
    ```

     是 

    ```
    ')'
    ```

    ：

    - **情况 1**：如果 `s[i-1]` 是 `'('`，即 `s[i-1]` 和 `s[i]` 构成一对有效括号。这时，`dp[i]` 可以通过 `dp[i-2] + 2` 计算得到（即以 `i-2` 为结尾的有效子串加上当前的这一对有效括号）。需要检查 `i-2` 是否有效。
    - **情况 2**：如果 `s[i-1]` 是 `')'`，我们需要检查 `s[i - dp[i-1] - 1]` 是否是 `'('`。如果是，那么我们可以将 `dp[i-1]` 代表的有效子串延伸为更长的有效子串。此时，`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`。

  ### 3. **初始化**

  - `dp[i] = 0` 对所有的 `i` 进行初始化，因为 `dp[i]` 存储的是以 `i` 结尾的有效子串的长度。如果当前 `i` 不形成有效子串，`dp[i]` 就为 `0`。
  - `dp[0]` 没有意义，因为单个字符无法形成有效括号子串。

  ### 4. **计算顺序**

  从左到右遍历字符串，计算每个 `dp[i]` 的值。每计算一个 `dp[i]`，我们就可以更新 `max_len` 来记录当前最大的有效括号子串长度。

  ### 5. **返回值**

  最终，返回 `dp` 数组中的最大值，即为最长有效括号子串的长度。

```python
class Solution(object):
    def longestValidParentheses(self, s):
        n = len(s)
        dp = [0] * n  # dp[i]表示以s[i]为结尾的最长有效括号子串的长度
        max_len = 0  # 记录最大长度
        
        for i in range(1, n):
            if s[i] == ')':
                if s[i - 1] == '(':  # 如果前一个字符是 '('
                    dp[i] = (dp[i - 2] if i >= 2 else 0) + 2  # 更新dp[i]
                elif i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == '(':  # 前面可以形成有效子串
                    dp[i] = dp[i - 1] + 2 + (dp[i - dp[i - 1] - 2] if i - dp[i - 1] - 2 >= 0 else 0)
                max_len = max(max_len, dp[i])
        
        return max_len
```



栈

```python
class Solution(object):
    def longestValidParentheses(self, s):
        n = len(s)
        if not n: return 0
        max_len = 0
        stack = [-1]
        for i, value in enumerate(s):
            if value == '(':
                stack.append(i)
            else:
                stack.pop()
                if stack:
                    max_len = max(max_len, i - stack[-1])
                else:
                    stack.append(i)
        return max_len
```

