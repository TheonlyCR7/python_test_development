## 94.中序遍历



```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[int]
        """
        ans = []
        def iteration_fun(node):
            if node:
                iteration_fun(node.left)
                ans.append(node.val)
                iteration_fun(node.right)
        iteration_fun(root)
        return ans
```



## 104.二叉树的最大深度



```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        
        def maxheap(node):
            if not node:
                return 0
            left_depth = maxheap(node.left)
            right_depth = maxheap(node.right)
            return max(left_depth, right_depth) + 1
        return maxheap(root)
```



## 226.翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```



思路：递归即可

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def invertTree(self, root):
        def iteration_fun(node):
            if node:
                iteration_fun(node.left)
                iteration_fun(node.right)
                temp = node.left
                node.left = node.right
                node.right = temp
        iteration_fun(root)
        return root
```



## 101.对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```



思路：

树的题目，因为树的特性，很多都可以用递归求解

先找到一个二层满二叉树的解法，然后递归到每个节点上

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        # 如果根节点为空，认为是对称的
        if not root:
            return True

        # 辅助函数，判断两个节点是否对称
        def isMirror(node1, node2):
            # 如果两个节点都为空，认为是对称的
            if not node1 and not node2:
                return True
            # 如果其中一个节点为空，另一个不为空，认为不对称
            if not node1 or not node2:
                return False
            # 比较节点值，并递归比较左右子树
            return (node1.val == node2.val) and isMirror(node1.left, node2.right) and isMirror(node1.right, node2.left)

        # 从根节点的左右子树开始判断对称性
        return isMirror(root.left, root.right)
```



## 543.二叉树的直径



```python
class Solution(object):
    def diameterOfBinaryTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        # 记录树的直径，初始化为1（因为树至少有一个节点，直径至少为0，但实际上是通过边数来计算的）
        self.ans = 1

        # 深度优先搜索（DFS）递归函数，计算节点的深度并更新最大直径
        def depth(node):
            # 基本情况：如果节点为空，返回深度为0
            if not node:
                return 0

            # 递归计算左子树和右子树的深度
            l = depth(node.left)
            r = depth(node.right)

            # 更新最大直径。当前节点的直径是左子树深度加右子树深度，即 l + r
            # 通过max选择左子树和右子树的深度的和，更新直径
            self.ans = max(self.ans, l + r + 1)

            # 返回当前节点的深度。当前节点的深度是其左子树和右子树的最大深度加1（表示当前节点本身）
            return max(l, r) + 1

        # 调用depth函数开始递归计算树的深度和更新直径
        depth(root)

        # 返回最大直径，减1是因为返回的是节点数，而直径是边数
        return self.ans - 1
```



## 102.层序遍历

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[List[int]]
        """
        if not root:
            return []
        queue, result = deque([root]), []

        while queue:
            level_size = len(queue)
            level_value = []
            for _ in range(level_size):
                node = queue.popleft()
                level_value.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            result.append(level_value)
        return result
```





## 108.将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵**平衡**二叉搜索树。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

思路：

难点在于“平衡”二字

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: Optional[TreeNode]
        """
        # 定义辅助函数，用于递归构建平衡二叉搜索树
        def helper(left, right):
            # 基本情况：如果左索引大于右索引，说明当前子数组为空，返回 None
            if left > right:
                return None
            
            # 选择中间元素作为根节点
            mid = (left + right) // 2
            
            # 创建当前根节点，值为当前子数组的中间元素
            node = TreeNode(nums[mid])
            
            # 递归构建左子树，处理左半部分的子数组
            node.left = helper(left, mid - 1)
            
            # 递归构建右子树，处理右半部分的子数组
            node.right = helper(mid + 1, right)
            
            # 返回当前创建的节点，该节点的左子树和右子树将通过递归被填充
            return node
        
        # 从根节点开始调用 helper 函数，处理整个数组
        return helper(0, len(nums) - 1)
```



## 98.验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于当前节点的数。

- 节点的右子树只包含 **大于** 当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

代码：

```python
class Solution(object):
    def isValidBST(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        def helper(node, lower = float('-inf'), upper = float('inf')):
            if not node:
                return True
            val = node.val
            if val <= lower or val >= upper:
                return False
            if not helper(node.left, lower, val):
                return False
            if not helper(node.right, val, upper):
                return False
            return True
        return helper(root)
```

其中，写法很巧妙

```python
if not helper(node.left, lower, val):
    return False
if not helper(node.right, val, upper):
    return False
return True
```

相同实现：

```python
if helper(node.left, lower, val):
	return True
else:
    return False
if helper(node.right, val, upper):
	return True
else:
    return False
```



注释版：

```python
class Solution(object):
    def isValidBST(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        # 定义一个辅助函数，用来验证二叉树是否是有效的二叉搜索树
        def helper(node, lower=float('-inf'), upper=float('inf')):
            # 如果当前节点为空，说明是一个有效的子树
            if not node:
                return True

            val = node.val  # 当前节点的值

            # 如果当前节点的值不符合二叉搜索树的范围，返回 False
            if val <= lower or val >= upper:
                return False

            # 递归检查左子树，左子树的值必须小于当前节点的值
            if not helper(node.left, lower, val):
                return False

            # 递归检查右子树，右子树的值必须大于当前节点的值
            if not helper(node.right, val, upper):
                return False

            # 如果所有的条件都符合，返回 True
            return True

        # 从根节点开始递归检查是否是有效的二叉搜索树
        return helper(root)
```



## 230.二叉搜索树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

中序遍历，秒了

```python
class Solution(object):
    def kthSmallest(self, root, k):
        lists = []
        def iteration_fun(node):
            if node:
                iteration_fun(node.left)
                lists.append(node.val)
                iteration_fun(node.right)
        iteration_fun(root)
        return lists[k-1]
```



## 199.二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1：**

**输入：**root = [1,2,3,null,5,null,4]

**输出：**[1,3,4]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png)

**示例 2：**

**输入：**root = [1,2,3,4,null,null,null,5]

**输出：**[1,3,4,5]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png)

**示例 3：**

**输入：**root = [1,null,3]

**输出：**[1,3]

**示例 4：**

**输入：**root = []

**输出：**[]



层次遍历，秒了

```python
from collections import deque
class Solution(object):
    def rightSideView(self, root):
        if not root: return []
        queue, result = deque([root]), []
        while(queue):
            level_size = len(queue)
            level_value = []
            for _ in range(level_size):
                node = queue.popleft()
                level_value.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            result.append(level_value[-1])
        return result
```



## 114.二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```



思路：

前序遍历+按要求进行链接

```python
class Solution:
    def flatten(self, root):
        preorderList = list()

        def preorderTraversal(root):
            if root:
                preorderList.append(root)
                preorderTraversal(root.left)
                preorderTraversal(root.right)
        
        preorderTraversal(root)
        size = len(preorderList)
        # 巧妙的写法，避免了指针越界问题
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr
```





## 105.从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```