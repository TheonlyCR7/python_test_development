## 基础思路

* 动态规划（DP）是算法中的核心思想，入门可以从**“自顶向下递归 → 记忆化优化 → 自底向上DP”**三步走。以下用最经典的**斐波那契数列**为例，手把手带你理解DP的核心逻辑。

  ---

  ### **一、DP核心思想**
  **本质**：将复杂问题分解为重叠子问题，通过存储中间结果避免重复计算，最终合并得到全局最优解。  
  **关键点**：  
  1. **状态定义**：用 `dp[i]` 表示问题的某个中间状态（如第i个斐波那契数）。  
  2. **状态转移方程**：如何从已知状态推导出下一个状态（如 `dp[i] = dp[i-1] + dp[i-2]`）。  
  3. **初始条件**：明确最小子问题的解（如 `dp[0]=0, dp[1]=1`）。  

  ---

  ### **二、从递归到DP的演化（以斐波那契为例）**
  #### **1. 暴力递归（自顶向下）**
  ```python
  def fib(n):
      if n <= 1:
          return n
      return fib(n-1) + fib(n-2)
  ```
  **问题**：重复计算严重（如计算 `fib(5)` 时 `fib(3)` 被计算多次）。时间复杂度 **O(2ⁿ)**。

  #### **2. 记忆化递归（优化重复计算）**
  ```python
  memo = {}  # 存储已计算的结果
  def fib(n):
      if n <= 1:
          return n
      if n not in memo:
          memo[n] = fib(n-1) + fib(n-2)  # 缓存结果
      return memo[n]
  ```
  **优化点**：通过哈希表存储中间结果，时间复杂度降为 **O(n)**，空间 **O(n)**。

  #### **3. 动态规划（自底向上迭代）**
  ```python
  def fib(n):
      if n <= 1:
          return n
      dp = [0] * (n+1)
      dp[0], dp[1] = 0, 1  # 初始条件
      for i in range(2, n+1):
          dp[i] = dp[i-1] + dp[i-2]  # 状态转移方程
      return dp[n]
  ```
  **优化点**：用数组代替递归栈，时间复杂度 **O(n)**，空间可进一步优化为 **O(1)**（只需保留前两个状态）。

  ---

  ### **三、DP解题四步法**
  1. **定义状态**：明确 `dp[i]` 的含义（如 `dp[i]` 表示第i个台阶的走法数）。  
  2. **写出转移方程**：找到 `dp[i]` 与 `dp[i-1]`、`dp[i-2]` 等的关系。  
  3. **初始化**：设置 `dp[0]`、`dp[1]` 等初始值。  
  4. **确定计算顺序**：通常从简单状态向复杂状态递推（如从 `i=2` 到 `i=n`）。

  ---

  ### **四、入门必刷经典题（按难度排序）**
  #### 1. **简单题 - 建立直觉**
  - **70. 爬楼梯**  
    - 状态定义：`dp[i]` 表示到第i阶楼梯的方法数。  
    - 转移方程：`dp[i] = dp[i-1] + dp[i-2]`（最后一步跨1阶或2阶）。  
  - **118. 杨辉三角**  
    - 状态定义：`dp[i][j]` 表示第i行第j列的值。  
    - 转移方程：`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`。

  #### 2. **中等题 - 掌握核心模型**
  - **53. 最大子数组和**  
    - 状态定义：`dp[i]` 表示以`nums[i]`结尾的最大子数组和。  
    - 转移方程：`dp[i] = max(dp[i-1] + nums[i], nums[i])`。  
  - **322. 零钱兑换**  
    - 状态定义：`dp[i]` 表示凑出金额i所需的最少硬币数。  
    - 转移方程：`dp[i] = min(dp[i - coin] + 1)`，对所有硬币面额`coin`。

  #### 3. **进阶题 - 理解多维状态**
  - **1143. 最长公共子序列**  
    - 状态定义：`dp[i][j]` 表示`text1[0..i]`和`text2[0..j]`的最长公共子序列长度。  
    - 转移方程：  
      ```python
      if text1[i] == text2[j]:
          dp[i][j] = dp[i-1][j-1] + 1
      else:
          dp[i][j] = max(dp[i-1][j], dp[i][j-1])
      ```

  ---

  ### **五、常见错误及避坑指南**
  1. **状态定义不清晰**：先画表格明确 `dp[i]` 的含义。  
  2. **忽略边界条件**：如 `dp[0]` 或 `dp[1]` 的初始化。  
  3. **转移方向错误**：确保计算 `dp[i]` 时所需的前置状态已计算。  

  ---

  ### **六、学习资源推荐**
  - 理论：B站《动态规划专题-闫氏DP分析法》  
  - 刷题：LeetCode动态规划专题（按通过率排序）  
  - 工具：画表格辅助推导（如Excel或手写推导 `dp` 数组的填充过程）。

  ---

  通过以上步骤，你可以在3-5天内掌握DP的核心逻辑。**关键是多动手画状态转移表，从简单题开始逐步抽象出通用模式**。遇到难题时，先尝试拆解问题是否符合“重叠子问题+最优子结构”的DP特征。