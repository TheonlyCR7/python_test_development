## 基础思路

* 动态规划（DP）是算法中的核心思想，入门可以从**“自顶向下递归 → 记忆化优化 → 自底向上DP”**三步走。以下用最经典的**斐波那契数列**为例，手把手带你理解DP的核心逻辑。

  ---

  ### **一、DP核心思想**
  **本质**：将复杂问题分解为重叠子问题，通过存储中间结果避免重复计算，最终合并得到全局最优解。  
  **关键点**：  
  1. **状态定义**：用 `dp[i]` 表示问题的某个中间状态（如第i个斐波那契数）。  
  2. **状态转移方程**：如何从已知状态推导出下一个状态（如 `dp[i] = dp[i-1] + dp[i-2]`）。  
  3. **初始条件**：明确最小子问题的解（如 `dp[0]=0, dp[1]=1`）。  

  ---

  ### **二、从递归到DP的演化（以斐波那契为例）**
  #### **1. 暴力递归（自顶向下）**
  ```python
  def fib(n):
      if n <= 1:
          return n
      return fib(n-1) + fib(n-2)
  ```
  **问题**：重复计算严重（如计算 `fib(5)` 时 `fib(3)` 被计算多次）。时间复杂度 **O(2ⁿ)**。

  #### **2. 记忆化递归（优化重复计算）**
  ```python
  memo = {}  # 存储已计算的结果
  def fib(n):
      if n <= 1:
          return n
      if n not in memo:
          memo[n] = fib(n-1) + fib(n-2)  # 缓存结果
      return memo[n]
  ```
  **优化点**：通过哈希表存储中间结果，时间复杂度降为 **O(n)**，空间 **O(n)**。

  #### **3. 动态规划（自底向上迭代）**
  ```python
  def fib(n):
      if n <= 1:
          return n
      dp = [0] * (n+1)
      dp[0], dp[1] = 0, 1  # 初始条件
      for i in range(2, n+1):
          dp[i] = dp[i-1] + dp[i-2]  # 状态转移方程
      return dp[n]
  ```
  **优化点**：用数组代替递归栈，时间复杂度 **O(n)**，空间可进一步优化为 **O(1)**（只需保留前两个状态）。

  ---

  ### **三、DP解题四步法**
  1. **定义状态**：明确 `dp[i]` 的含义（如 `dp[i]` 表示第i个台阶的走法数）。  
  2. **写出转移方程**：找到 `dp[i]` 与 `dp[i-1]`、`dp[i-2]` 等的关系。  
  3. **初始化**：设置 `dp[0]`、`dp[1]` 等初始值。  
  4. **确定计算顺序**：通常从简单状态向复杂状态递推（如从 `i=2` 到 `i=n`）。

  ---

  ### **四、入门必刷经典题（按难度排序）**
  #### 1. **简单题 - 建立直觉**
  - **70. 爬楼梯**  
    - 状态定义：`dp[i]` 表示到第i阶楼梯的方法数。  
    - 转移方程：`dp[i] = dp[i-1] + dp[i-2]`（最后一步跨1阶或2阶）。  
  - **118. 杨辉三角**  
    - 状态定义：`dp[i][j]` 表示第i行第j列的值。  
    - 转移方程：`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`。

  #### 2. **中等题 - 掌握核心模型**
  - **53. 最大子数组和**  
    - 状态定义：`dp[i]` 表示以`nums[i]`结尾的最大子数组和。  
    - 转移方程：`dp[i] = max(dp[i-1] + nums[i], nums[i])`。  
  - **322. 零钱兑换**  
    - 状态定义：`dp[i]` 表示凑出金额i所需的最少硬币数。  
    - 转移方程：`dp[i] = min(dp[i - coin] + 1)`，对所有硬币面额`coin`。

  #### 3. **进阶题 - 理解多维状态**
  - **1143. 最长公共子序列**  
    - 状态定义：`dp[i][j]` 表示`text1[0..i]`和`text2[0..j]`的最长公共子序列长度。  
    - 转移方程：  
      ```python
      if text1[i] == text2[j]:
          dp[i][j] = dp[i-1][j-1] + 1
      else:
          dp[i][j] = max(dp[i-1][j], dp[i][j-1])
      ```

  ---

  ### **五、常见错误及避坑指南**
  1. **状态定义不清晰**：先画表格明确 `dp[i]` 的含义。  
  2. **忽略边界条件**：如 `dp[0]` 或 `dp[1]` 的初始化。  
  3. **转移方向错误**：确保计算 `dp[i]` 时所需的前置状态已计算。  

  ---

  ### **六、学习资源推荐**
  - 理论：B站《动态规划专题-闫氏DP分析法》  
  - 刷题：LeetCode动态规划专题（按通过率排序）  
  - 工具：画表格辅助推导（如Excel或手写推导 `dp` 数组的填充过程）。

  ---

  通过以上步骤，你可以在3-5天内掌握DP的核心逻辑。**关键是多动手画状态转移表，从简单题开始逐步抽象出通用模式**。遇到难题时，先尝试拆解问题是否符合“重叠子问题+最优子结构”的DP特征。



## 题型总结和模板

* 动态规划（Dynamic Programming，简称 DP）是一种将复杂问题分解成更简单子问题的方法。它通常适用于具有 **重叠子问题** 和 **最优子结构** 的问题。动态规划的核心思想是通过记忆化或状态转移来避免重复计算。

  下面是常见的动态规划题型及其模板。掌握这些模板将帮助你高效地解决动态规划相关的题目。

  ### 一、动态规划的基本思路

  1. **问题分解**：将原问题分解为多个子问题。
  2. **状态定义**：确定动态规划数组或表格的定义，通常用 `dp[i]` 表示子问题的最优解。
  3. **状态转移**：找到子问题之间的关系，推导出状态转移方程。
  4. **边界条件**：定义初始状态。
  5. **目标问题**：最后返回目标问题的解。

  ### 二、常见动态规划题型

  #### 1. **背包问题系列**

  背包问题是动态规划中最经典的题型，涉及选择物品、容量限制、最大化价值等问题。

  **模板**：

  - **01 背包**：每个物品只能选择一次。
  - **完全背包**：每个物品可以选择任意次。
  - **多重背包**：每个物品有一定的数量限制。

  **状态定义**：

  - `dp[i][j]` 表示前 `i` 个物品，容量为 `j` 时的最大价值。

  **状态转移方程**：

  ```python
  # 01背包
  dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
  
  # 完全背包
  dp[i][j] = max(dp[i][j], dp[i][j-weight[i]] + value[i])
  
  # 多重背包
  dp[i][j] = max(dp[i][j], dp[i-1][j-k*weight[i]] + k*value[i])
  ```

  **常见题目**：

  - 0-1 背包问题
  - 完全背包问题
  - 多重背包问题

  ------

  #### 2. **区间型问题**

  这类问题通常是要求在一个区间内选择或分割，常见的有最小值、最大值、和等。

  **状态定义**：

  - `dp[i][j]` 表示从第 `i` 到第 `j` 个元素的最优解。

  **状态转移方程**：

  ```python
  # 示例：求子数组的最大和
  dp[i][j] = max(dp[i][k] + dp[k+1][j])   # 选择合适的区间分割点
  ```

  **常见题目**：

  - 打家劫舍
  - 最长递增子序列（LIS）
  - 最大子数组和（Kadane 算法）

  ------

  #### 3. **字符串问题**

  字符串相关的动态规划问题通常涉及到 **编辑距离**，**最长公共子序列**，**正则匹配** 等。

  **状态定义**：

  - `dp[i][j]` 表示字符串 `s1[0..i-1]` 和 `s2[0..j-1]` 的最优解。

  **状态转移方程**：

  ```python
  # 编辑距离
  dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (s1[i-1] != s2[j-1]))
  
  # 最长公共子序列
  dp[i][j] = dp[i-1][j-1] + 1 if s1[i-1] == s2[j-1] else max(dp[i-1][j], dp[i][j-1])
  ```

  **常见题目**：

  - 编辑距离（Levenshtein 距离）
  - 最长公共子序列（LCS）
  - 正则表达式匹配

  ------

  #### 4. **矩阵型问题**

  这类问题通常是要求在一个矩阵或图中找到某种路径、最大或最小值。

  **状态定义**：

  - `dp[i][j]` 表示到达矩阵位置 `(i, j)` 的最优解。

  **状态转移方程**：

  ```python
  dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
  ```

  **常见题目**：

  - 最小路径和
  - 最大正方形
  - 矩阵中的最大值路径

  ------

  #### 5. **树形动态规划**

  树形动态规划问题通常涉及到树的遍历和子树的状态转移，常见的题目有树的最大深度、树的最小路径等。

  **状态定义**：

  - `dp[i]` 表示以节点 `i` 为根的子树的最优解。

  **状态转移方程**：

  ```python
  dp[i] = max(dp[left], dp[right]) + 1   # 例如，树的高度
  ```

  **常见题目**：

  - 二叉树的最大深度
  - 树的直径

  ------

  #### 6. **动态规划 + 滚动数组优化**

  对于一些动态规划问题，可以利用**滚动数组**来减少空间复杂度。特别是当 `dp[i]` 只与 `dp[i-1]` 或 `dp[i-2]` 等前一个状态有关时，我们可以用一维数组替代二维数组。

  **优化方式**：

  ```python
  # 例如 斐波那契数列
  dp = [0] * (n + 1)
  dp[1] = 1
  for i in range(2, n+1):
      dp[i] = dp[i-1] + dp[i-2]
  ```

  ------

  ### 三、总结常见动态规划模板

  1. **背包问题**（0-1 背包、完全背包、多重背包）：

     ```python
     dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
     ```

  2. **区间问题**（子区间的最优解）：

     ```python
     dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
     ```

  3. **字符串问题**（编辑距离、最长公共子序列）：

     ```python
     dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (s1[i-1] != s2[j-1]))
     ```

  4. **矩阵型问题**（最短路径、最大正方形等）：

     ```python
     dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
     ```

  5. **树形问题**（树的最大深度、最小路径等）：

     ```python
     dp[i] = max(dp[left], dp[right]) + 1
     ```

  6. **滚动数组优化**：

     ```python
     dp[i] = dp[i-1] + dp[i-2]
     ```

  ### 四、总结

  动态规划是一种通过将大问题分解为小问题来求解的有效方法。掌握动态规划的常见题型和模板，可以帮助你高效解决各种优化问题。通过识别问题的**重叠子问题**和**最优子结构**，你可以选择合适的状态表示和转移方程，最终解决问题。