## 160.相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

 

**示例 1：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

 

**示例 2：**

[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：No intersection
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```



错误做法：

直接进行循环遍历，比较。忽略了链表长度不一致的情况

```python
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        if headA == None or headB == None: return 0
        while(headA.next != None and headB.next != None):
            if headA.next == headB.next:
                return headA.next
            headA = headA.next
            headB = headB.next
        return 0
```

要去寻找相同 的引用，而不是相同 的值

```python
class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type headA: ListNode
        :type headB: ListNode
        :rtype: ListNode
        """
        if not headA or not headB:
            return None
        
        # 使用集合存储链表 A 的节点引用
        nodes_in_A = set()
        
        # 遍历链表 A，将所有节点加入集合
        currentA = headA
        while currentA:
            nodes_in_A.add(currentA) # 将引用添加到集合中
            currentA = currentA.next
        
        # 遍历链表 B，检查是否存在节点在集合中
        currentB = headB
        while currentB:
            if currentB in nodes_in_A:  # 查找相同引用
                return currentB
            currentB = currentB.next
        
        # 如果没有交点，返回 None
        return None
```



## 206.反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```
输入：head = []
输出：[]
```

思路：

利用栈进行反转，压入再弹出

```python
from collections import deque

class Solution(object):
    def reverseList(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        if not head:  # 空链表
            return None

        # 使用栈存储链表节点
        stack = deque()
        current = head

        # 将链表节点压入栈
        while current:
            stack.append(current)
            current = current.next

        # 从栈中弹出节点，重构链表
        new_head = stack.pop()  # 新的头节点
        current = new_head
        while stack:
            current.next = stack.pop()
            current = current.next
        
        # 最后一个节点的 next 指针应指向 None
        current.next = None
        return new_head

```





## 234.回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为

回文链表

。如果是，返回 `true` ；否则，返回 `false` 。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```



思路：

将元素存储到列表中，然后列表与列表翻转后的进行比较，相同则为回文

```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        vals = []
        current_node = head
        while current_node is not None:
            vals.append(current_node.val)
            current_node = current_node.next
        return vals == vals[::-1]  # 将列表翻转
```

第二种：递归

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def isPalindrome(self, head):

        self.front_pointer = head

        def recursively_check(current_node=head):
            if current_node is not None:
                if not recursively_check(current_node.next):
                    return False
                if self.front_pointer.val != current_node.val:
                    return False
                self.front_pointer = self.front_pointer.next
            return True

        return recursively_check()
```





## 141.环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)



```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```



思路：用集合或是字典来存储节点信息，查看每个节点再集合中是否已经存在，若存在，则环形

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        if head == None or head.next == None: return False
        hashtable = defaultdict()
        index = 0
        while(head != None):
            if head not in hashtable:
                hashtable[head] = index
                head = head.next
                index += 1
            else:
                return index
```



## 143.环形链表Ⅱ

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

秒杀

```Python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None or head.next == None: return None
        hashtable = defaultdict()
        index = 0
        while(head != None):
            if head not in hashtable:
                hashtable[head] = index
                head = head.next
                index += 1
            else:
                return head
        return None
```



## 21.合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

思路：

创建新链表，双指针遍历两个链表，大小比较后链接新的链表

```python
class Solution(object):
    def mergeTwoLists(self, list1, list2):
        """
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        # 创建哑节点作为新链表的起点
        dummy = ListNode(-1)
        current = dummy

        # 遍历两个链表，将较小值节点加入新链表
        while list1 and list2:
            if list1.val < list2.val:
                current.next = list1
                list1 = list1.next
            else:
                current.next = list2
                list2 = list2.next
            current = current.next

        # 处理剩余的节点
        current.next = list1 if list1 else list2

        # 返回哑节点后的实际链表头
        return dummy.next
```



## 2.两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```



思路：

模仿加法过程，逐个相加，考虑进位

```python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: Optional[ListNode]
        :type l2: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        tip = 0  # 进位
        dummy = ListNode(-1)  # 哑节点
        cur = dummy  # 指针，用于构建结果链表

        # 遍历两个链表，同时处理进位
        while l1 or l2 or tip:
            # 获取当前节点的值，如果链表已经为空，则用 0 代替
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0

            # 计算两数之和，并处理进位
            total = val1 + val2 + tip
            tip = total // 10  # 更新进位
            cur.next = ListNode(total % 10)  # 当前节点的值
            cur = cur.next

            # 移动到下一个节点
            if l1: l1 = l1.next
            if l2: l2 = l2.next

        # 返回结果链表（去除哑节点）
        return dummy.next
```



## 19.删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**示例 2：**

```
输入：head = [1], n = 1
输出：[]
```

**示例 3：**

```
输入：head = [1,2], n = 1
输出：[1]
```



思路：

先对链表进行遍历，知道链表的长度，然后再进行删除节点

```python
class Solution:
    def removeNthFromEnd(self, head, n):
        def getLength(head):
            length = 0
            while head:
                length += 1
                head = head.next
            return length
        
        dummy = ListNode(0, head)
        length = getLength(head)
        cur = dummy
        for i in range(1, length - n + 1):
            cur = cur.next
        cur.next = cur.next.next
        return dummy.next
```

思路二：递归

```python
class Solution(object):
    def removeNthFromEnd(self, head, n):
        # 定义一个递归函数
        def remove(node):
            if not node:  # 递归到链表末尾
                return 0  # 返回索引 0
            index = remove(node.next) + 1  # 递归返回时计算当前节点的索引
            if index == n + 1:  # 找到倒数第 n+1 个节点
                node.next = node.next.next  # 跳过倒数第 n 个节点
            return index  # 返回当前节点的索引

        # 创建一个哑节点，便于处理删除头节点的特殊情况
        dummy = ListNode(0)
        dummy.next = head
        remove(dummy)  # 从哑节点开始递归
        return dummy.next  # 返回新的链表头
```



## 24.两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

思路：

遍历即可

```python
class Solution(object):
    def swapPairs(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        if head == None: return None
        if head.next == None: return head

        pre = head
        las = head.next
        while(True):
            temp = pre.val
            pre.val = las.val
            las.val = temp
            if las.next != None and las.next.next != None:
                pre = pre.next.next
                las = las.next.next
            else:
                break
        return head
```



## 25.K个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```



代码：

```python
class Solution:
    # 翻转一个子链表，并且返回新的头与尾
    # 使用原地翻转，不使用额外的存储空间
    def reverse(self, head, tail):
        # `prev` 表示翻转后子链表的下一个部分（即原来的 `tail.next`）
        prev = tail.next
        # `p` 用于遍历子链表，从 `head` 开始
        p = head
        # 当 `prev` 尚未移动到 `tail` 时，逐步反向指针
        while prev != tail:
            # 暂存当前节点的下一个节点
            nex = p.next
            # 翻转当前节点指针，指向 `prev`
            p.next = prev
            # 移动 `prev` 和 `p` 指针
            prev = p
            p = nex
        # 返回翻转后的新头和新尾
        return tail, head

    # 按每 k 个节点为一组翻转链表
    def reverseKGroup(self, head, k):
        # 哑节点，简化链表操作
        hair = ListNode(0)
        hair.next = head
        # `pre` 用于记录需要翻转子链表的前一个节点
        pre = hair

        # 遍历链表，按 k 组翻转
        while head:
            tail = pre
            # 检查剩余部分的长度是否大于等于 k
            for i in range(k):
                tail = tail.next
                # 如果长度不足 k，则不需要翻转，直接返回结果
                if not tail:
                    return hair.next
            # 记录翻转后的下一个部分
            nex = tail.next
            # 翻转从 `head` 到 `tail` 的子链表
            head, tail = self.reverse(head, tail)
            # 将翻转后的子链表接回主链表
            pre.next = head
            tail.next = nex
            # 更新 `pre` 和 `head` 指针，准备处理下一组
            pre = tail
            head = tail.next
        
        # 返回处理后的链表头
        return hair.next
```

