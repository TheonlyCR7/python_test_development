## TCP，UDP概念，TCP连接和断开

* ### **TCP与UDP的基本原理**

  #### **1. TCP（Transmission Control Protocol）— 传输控制协议**

  TCP 是一种面向连接、可靠的传输协议，提供端到端的数据传输服务，确保数据的完整性和顺序性。其主要特点包括：

  - **面向连接**：通信双方在数据传输前需要建立连接。
  - **可靠传输**：采用序号（Sequence Number）、确认（ACK）、超时重传等机制，确保数据无误到达。
  - **有序传输**：TCP 报文有序编号，接收方可按照序号重排数据，避免乱序问题。
  - **流量控制**：通过滑动窗口机制（Sliding Window）控制发送方的发送速率，以适应接收方的处理能力。
  - **拥塞控制**：包括慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）和快速恢复（Fast Recovery）等机制，避免网络拥塞。

  #### **2. UDP（User Datagram Protocol）— 用户数据报协议**

  UDP 是一种无连接、非可靠的传输协议，适用于对实时性要求高、对可靠性要求较低的场景。其主要特点包括：

  - **无连接**：数据传输前不建立连接，直接发送数据。
  - **不可靠**：不保证数据按序到达，也不保证数据是否到达。
  - **低开销**：相较于 TCP，UDP 头部更小，协议开销更低。
  - **面向报文**：UDP 以报文为单位发送和接收，应用层需要自行处理数据的完整性和顺序问题。
  - **适用于实时应用**：如 VoIP（网络电话）、视频直播、DNS（域名解析）、TFTP（简单文件传输协议）等。

  ------

  ### **TCP 三次握手（Three-Way Handshake）**

  TCP 在通信前需要建立连接，采用 **三次握手** 机制，以确保双方能够正确收发数据，避免错误连接的建立。

  #### **三次握手过程**

  1. **第一次握手（SYN = 1, Seq = X）**
     - 客户端发送一个 **SYN（Synchronize）** 报文，表示请求建立连接，并携带一个初始序列号 **Seq = X**。
     - 进入 **SYN-SENT** 状态。
  2. **第二次握手（SYN = 1, ACK = 1, Seq = Y, Ack = X+1）**
     - 服务器收到 SYN 后，返回 **SYN + ACK** 报文，表示同意连接，并携带自己的初始序列号 **Seq = Y** 和确认号 **Ack = X+1**（表明已收到客户端的 SYN）。
     - 进入 **SYN-RECEIVED** 状态。
  3. **第三次握手（ACK = 1, Seq = X+1, Ack = Y+1）**
     - 客户端收到服务器的 SYN + ACK 后，发送 **ACK** 报文，确认收到服务器的响应。
     - 进入 **ESTABLISHED**（连接建立）状态，服务器也进入 **ESTABLISHED** 状态，连接正式建立。

  #### **为什么需要三次握手？**

  - **防止旧连接请求干扰**：如果仅采用两次握手，可能会导致服务器错误地建立一个已经过期的连接。
  - **确保双方收发能力正常**：三次握手确保客户端和服务器的发送、接收能力正常，避免盲目建立连接。

  ------

  ### **TCP 四次挥手（Four-Way Handshake）**

  TCP 连接断开时，需要双方都同意断开连接，因此采用 **四次挥手** 机制，确保数据传输完成后安全断开。

  #### **四次挥手过程**

  1. **第一次挥手（FIN = 1, Seq = U）**
     - 客户端发送 **FIN（Finish）** 报文，表示不再发送数据，但仍能接收数据。
     - 进入 **FIN-WAIT-1** 状态。
  2. **第二次挥手（ACK = 1, Seq = V, Ack = U+1）**
     - 服务器收到 FIN 后，返回 **ACK** 报文，确认收到断开请求，但可能仍有数据未发送完毕。
     - 进入 **CLOSE-WAIT** 状态，客户端进入 **FIN-WAIT-2** 状态。
  3. **第三次挥手（FIN = 1, Seq = W）**
     - 服务器发送 **FIN** 报文，表示数据已发送完毕，准备断开连接。
     - 进入 **LAST-ACK** 状态。
  4. **第四次挥手（ACK = 1, Seq = X, Ack = W+1）**
     - 客户端收到 FIN 后，发送 **ACK** 确认报文。
     - 进入 **TIME-WAIT** 状态，等待一段时间（默认 2MSL，约 4 分钟）后才完全关闭，以防服务器未收到最后的 ACK。
     - 服务器在收到 ACK 后直接进入 **CLOSED** 状态，连接断开。

  #### **为什么需要四次挥手？**

  - **确保数据传输完成**：TCP 是全双工通信，数据传输方向需要分别关闭。
  - **等待可能的重传**：客户端进入 TIME-WAIT 状态，确保服务器收到 ACK，否则可重传。

  ------

  ### **总结**

  | 特性     | TCP                                   | UDP                                             |
  | -------- | ------------------------------------- | ----------------------------------------------- |
  | 连接     | 面向连接（需要三次握手）              | 无连接                                          |
  | 可靠性   | 可靠传输（数据有序、无丢失）          | 不可靠（可能丢包、乱序）                        |
  | 速度     | 相对较慢（需确认、重传）              | 传输快（无确认、无需重传）                      |
  | 适用场景 | 需要可靠传输的应用（HTTP、FTP、邮件） | 需要实时性、高速传输的应用（VoIP、视频流、DNS） |

  TCP 通过三次握手建立连接，四次挥手断开连接，确保数据可靠传输。而 UDP 采用无连接、尽力而为的方式，适用于对实时性要求高但可靠性要求较低的应用场景。



## TCP连接和断开的标志位

* 在 TCP 三次握手和四次挥手的过程中，涉及多个 TCP 头部标志位和字段。以下是它们的具体含义：

  ------

  ### **TCP 头部中的关键字段**

  1. **SYN（Synchronize，标志位）**
     - 用于建立连接的同步标志位。
     - 在三次握手的前两次通信中使用。
     - `SYN = 1` 表示请求建立连接。
  2. **ACK（Acknowledgment，标志位）**
     - 确认标志位，表示对收到的数据或连接请求的确认。
     - `ACK = 1` 表示该报文是对之前数据的确认。
     - 三次握手和四次挥手过程中都要使用 ACK。
  3. **FIN（Finish，标志位）**
     - 结束标志位，用于断开 TCP 连接。
     - `FIN = 1` 表示发送方不再发送数据，请求断开连接。
     - 需要对 FIN 进行确认（ACK）。
  4. **Seq（Sequence Number，序列号）**
     - 表示当前 TCP 报文段的序号。
     - TCP 是**面向字节流**的协议，每发送一个字节，序号都会增加。
     - 通过 Seq，接收方可以知道数据的顺序，并进行重排。
  5. **Ack（Acknowledgment Number，确认号）**
     - 确认号，表示对方期望收到的下一个字节的序列号。
     - 例如：
       - 发送方发送 `Seq = 100`，数据长度为 10 字节。
       - 接收方成功接收后，会返回 `Ack = 110`，表示下一个期望的字节序号是 110。

  ------

  ### **TCP 三次握手详细过程解析**

  1. **第一次握手（客户端 → 服务器）**

     - 发送 `SYN`，请求建立连接。
     - 包含初始序列号 `Seq = X`（随机生成）。
     - 标志位：`SYN = 1`，`ACK = 0`。
     - 服务器收到后，进入 `SYN-RECEIVED` 状态。

     ```
     客户端 → 服务器： SYN=1, Seq=X
     ```

  2. **第二次握手（服务器 → 客户端）**

     - 服务器返回 `SYN + ACK`，确认连接请求。
     - 服务器的 `Seq = Y`（随机生成），同时 `Ack = X + 1`（确认收到 X）。
     - 标志位：`SYN = 1`，`ACK = 1`。
     - 客户端收到后，进入 `ESTABLISHED`（已建立连接）状态。

     ```
     服务器 → 客户端： SYN=1, ACK=1, Seq=Y, Ack=X+1
     ```

  3. **第三次握手（客户端 → 服务器）**

     - 客户端确认服务器的 `SYN`，返回 `ACK`。
     - `Seq = X + 1`，`Ack = Y + 1`。
     - 标志位：`ACK = 1`，`SYN = 0`。
     - 服务器进入 `ESTABLISHED` 状态，连接正式建立。

     ```
     客户端 → 服务器： ACK=1, Seq=X+1, Ack=Y+1
     ```

  ------

  ### **TCP 四次挥手详细过程解析**

  1. **第一次挥手（客户端 → 服务器）**

     - 客户端请求断开连接，发送 `FIN`。
     - `Seq = U`，`FIN = 1`，表示不再发送数据，但仍可接收数据。
     - 服务器进入 `CLOSE-WAIT` 状态，客户端进入 `FIN-WAIT-1` 状态。

     ```
     客户端 → 服务器： FIN=1, Seq=U
     ```

  2. **第二次挥手（服务器 → 客户端）**

     - 服务器返回 `ACK`，确认收到 `FIN`。
     - `Ack = U + 1`。
     - 服务器仍可能有数据要发送，因此暂不发送 `FIN`。
     - 服务器保持 `CLOSE-WAIT` 状态，客户端进入 `FIN-WAIT-2` 状态。

     ```
     服务器 → 客户端： ACK=1, Ack=U+1
     ```

  3. **第三次挥手（服务器 → 客户端）**

     - 服务器数据发送完毕后，主动断开连接，发送 `FIN`。
     - `Seq = W`，`FIN = 1`，进入 `LAST-ACK` 状态。
     - 客户端收到后，进入 `TIME-WAIT` 状态。

     ```
     服务器 → 客户端： FIN=1, Seq=W
     ```

  4. **第四次挥手（客户端 → 服务器）**

     - 客户端发送 `ACK`，确认收到 `FIN`。
     - `Ack = W + 1`，`ACK = 1`。
     - 服务器进入 `CLOSED` 状态，完全关闭连接。
     - 客户端进入 `TIME-WAIT` 状态，等待 2MSL（最长报文段生存时间），然后关闭。

     ```
     客户端 → 服务器： ACK=1, Ack=W+1
     ```

  ------

  ### **总结**

  | 标志位 | 作用                         |
  | ------ | ---------------------------- |
  | SYN    | 建立连接请求                 |
  | ACK    | 确认收到数据                 |
  | FIN    | 断开连接请求                 |
  | Seq    | 数据包的序列号               |
  | Ack    | 期望接收的下一个字节的序列号 |

  TCP 通过 **SYN、ACK、FIN** 等标志位以及 **Seq、Ack** 这些序列号来确保数据的可靠传输和连接管理。



## ACK和Ack

* **ACK（标志位）**和**Ack（确认号）**是 TCP 头部中的两个不同概念，分别用于指示确认的状态和确认的数据编号。

  ------

  ### **ACK（Acknowledgment Flag，确认标志位）**

  - **作用**：表示当前 TCP 报文是否是一个“确认”报文。

  - **位置**：TCP 头部中的 **标志位（Flags）**字段之一。

  - 取值

    ：

    - `ACK = 1`：表示该报文是对之前数据的确认。
    - `ACK = 0`：表示该报文没有确认功能（如 SYN 连接请求的第一次握手）。

  - 应用场景

    ：

    - TCP 三次握手和四次挥手过程中，通常 `ACK = 1`，用于确认对方的 SYN 或 FIN。
    - 数据传输过程中，每当接收方成功接收数据，都会返回 `ACK = 1` 的报文，告知发送方。

  示例：

  ```
  服务器 → 客户端： ACK=1
  ```

  表示服务器确认收到客户端的请求。

  ------

  ### **Ack（Acknowledgment Number，确认号）**

  - **作用**：用于指示下一个期望收到的字节序号。

  - **位置**：TCP 头部中的 **确认号（Acknowledgment Number）**字段。

  - 计算方式

    ：

    - 若发送方的 **Seq = X** 且数据长度为 N，则接收方返回 **Ack = X + N**，表示期望接收从 `X+N` 开始的数据。

  - 应用场景

    ：

    - 用于 TCP 确保数据按序传输，防止丢失或乱序。
    - 每次收到数据后，接收方都会发送带有 Ack 值的 **ACK 确认报文**，让发送方知道哪些数据已成功接收。

  示例：

  ```
  服务器 → 客户端： ACK=1, Ack=1001
  ```

  表示服务器确认收到数据，并期望下次收到从 **1001** 开始的数据。

  ------

  ### **区别总结**

  | 对比项       | ACK（标志位）               | Ack（确认号）                      |
  | ------------ | --------------------------- | ---------------------------------- |
  | **作用**     | 标识该报文是否为确认报文    | 指定期望收到的下一个字节序号       |
  | **位置**     | TCP 头部的标志位字段        | TCP 头部的确认号字段               |
  | **取值**     | 0（无确认）、1（确认）      | 具体的序号值                       |
  | **作用范围** | 仅表示该报文具有确认功能    | 指明数据流的序列控制               |
  | **示例**     | `ACK = 1`（表示是确认报文） | `Ack = 1001`（期望下次接收的序号） |

  ------

  ### **结合示例**

  假设：

  - 发送方发送 

    Seq = 100

    ，数据长度 

    50

    ，则接收方应当返回：

    ```
    ACK=1, Ack=150
    ```

    其中：

    - `ACK = 1` 表示是一个确认报文。
    - `Ack = 150` 表示期望收到下一个字节的序号是 150。

  这样，TCP 通过 **ACK 标志位** 确认报文的有效性，利用 **Ack 号** 确保数据有序传输。







## 为什么要三次握手，二次不行吗

**潜在风险**：

- **场景 1：旧 SYN 连接请求的延迟**
  - 客户端之前曾发送 `SYN=1, Seq=X` 请求，但由于网络拥塞等原因，该报文长时间滞留在网络中。
  - 服务器后来因超时机制关闭了连接，但此时旧的 `SYN` 终于到达服务器。
  - 服务器误以为是新的连接请求，发送 `SYN + ACK`，并建立了错误的连接。
- **场景 2：客户端错误关闭连接**
  - 客户端在收到 `SYN + ACK` 之前崩溃或重启，导致它并不知道服务器已准备好通信。
  - 服务器仍然认为连接已建立，等待客户端的数据，但客户端根本不会再发送数据，导致服务器资源浪费。





```

```

